---
output: xaringan::moon_reader
title: "Writing Functions in R"
runtime: shiny_prerendered
---

```{r include = FALSE}
library(learnr)
```

As an R user, you already know how to use functions! Functions enable everything we do in R - from reading in a CSV

library(readr)
read_csv()

to calculating a mean

mean()

making a plot

ggplot() + 
geom_point()

fitting a model

lm(y ~ x)

everything in between and beyond.

Functions allow you to better organize and reuse your code - so today we're going to learn how to write our own.

---

I love to cook, and my favourite cookbook author is Isa Chandra Moscowitz. She's American, so she tends to give quantities of stuff like pasta in ounces The amount of times I've googled "8 oz to grams" or "16 oz to grams" is astronomical!

```{r}
8 * 28.35
16 * 28.35
```

Wouldn't it be nice if I had an R function to do this for me?

```{r}
convert_oz_to_grams <- function(oz) {
  oz * 28.35
}

convert_oz_to_grams(8)
convert_oz_to_grams(16)
```

---

# Writing R Functions

Functions can be used to:

* Have a single place to update logic for repeated operations
* Reduce error prone copy and pasting in your code
* Make your code easier to understand by focusing on what the code *does* rather than low-level computational details

TODO ensure to cover intermediate variables - needs to be in the concept map!

arguments should be CONSISTENT across functions - use str_  vs grep set of functions to demonstrate

TODO order of calling arguments versus by name

---

# Components of a function

A function, like the one we just wrote, typically has **three** main components:

1. A name
2. Arguments
3. A body

???

Name is what is assigned to

Arguments - 0 or more, within `function()`

Body - everything between {}, actually has the code to do the computations we want

---

# Naming functions

Functions should be named clearly and meaningfully, to help yourself write (and read!) code that is easier to understand - the names are for people as much as for computers!

convert_oz_to_grams()

I like to use snake_case, but some people like camelCase - use whatever feels right for you!

---

# Naming functions

If you're creating many functions, it's helpful to name them consistently

The stringr package is a great example of this

str_replace()

str_detect()

You may not know what you're looking for yet, but you know how it starts!

---

```{r naming}
question(
  "Imagine you're writing a function to convert kilograms to pounds. Which name would you choose for your function?",
  allow_retry = TRUE,
  random_answer_order = TRUE,
  answer("convert_kg_to_lb()", correct = TRUE, message = "Yes! The name is clear as to what it does - converts kilograms to pounds - and reads \"in English\" without ambiguity as to what it does"),
  answer("weight_converter()", message = "This function name does not clearly convey which way the conversion is happening - are pounds being converted to kilograms, or vice versa? What units are used? Ounces? It would likely result in more misuse, or the need to continuously read the documentation."),
  answer("kgtolb()", message = "While this name conveys that kg are being converted to pounds, it is difficult to read all as one word."),
  answer("Kilogram_ToPounds()", message = "This function name combines two popular naming conventions - snake_case and CamelCase. Combining both would likely make it more difficult for a user to remember the function name when the time comes to use it.")
)
```

---

# Arguments

Arguments describe what your function works on, and *how* it works.

e.g. `oz` in convert_oz_to_grams()

There are two types of arguments:

Data: what the computation is on

Details: How it works

The data should come first

```{r}
convert_oz_to_grams <- function(oz) {
  oz * 28.35
}
```

Just has data, but we could add details - my kitchen scale only shows to the nearest gram, so 

```{r}
convert_oz_to_grams(8)
```

iisn't useful

Add *details* that control how the computation is run, e.g. how many digits to round to

```{r}
convert_oz_to_grams <- function(oz, digits) {
  round(oz * 28.349, digits = digits)
}

convert_oz_to_grams(8, digits = 0)
convert_oz_to_grams(8, digits = 1)
convert_oz_to_grams(8, digits = 2)
```

It might be cumbersome to say I want zero digits every time - but you can give an argument a *default* value, which is the value that the function uses if nothing is supplied!

GOOD TIME TO LIVE CODE

```{r}
convert_oz_to_grams <- function(oz, digits = 0) {
  round(oz * 28.349, digits = digits)
}
```

Now I can run the function with nothing set for `digits`, and it will use 0!@

```{r}
convert_oz_to_grams(8)
```

In general it's best to set the default value to what you'll use most often!

How do you name arguments?

HINT - if you're looking for ideas of what to name an argument, look at functions that do something similar - e.g. look at round() for digits, mean() for na.rm, etc

---

# Function Body

The body of a function controls all of the computation that happens! We have seen a few examples of what a function body can contain already.

A function returns the last computation in the body.

```{r}
convert_oz_to_grams <- function(oz, digits = 0) {
  round(oz * 28.349, digits = digits)
}
```

If you're writing a complicated function, it might be helpful to split things up into steps. You can create intermediate variables to take things one step at a time - these will only exist in the function, not elsewhere

MAYBE LIVE CODE HERE? to show that grams doesn't exist outside

```{r}
convert_oz_to_grams <- function(oz, digits = 0) {
  grams <- oz * 28.35
  
  round(grams, digits = digits)
}
```

TIME FOR MULTIPLE RETURN VALUES?
